<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>0</epicId>
    <storyId>3</storyId>
    <title>Implement Debug Logging System</title>
    <status>drafted</status>
    <generatedAt>2025-11-28</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>dev/sprint-artifacts/0-3-implement-debug-logging-system.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer working on the ollatool CLI</asA>
    <iWant>a DEBUG logging system with namespace support and zero console output by default</iWant>
    <soThat>I can enable detailed logging during development and troubleshooting while maintaining clean UX in normal operation</soThat>
    <tasks>
- Task 1: Install and configure debug logging library (AC: #1, #2)
  - Subtask 1.1: Install `debug` package as development dependency
  - Subtask 1.2: Create logger instances for git, llm, and perf namespaces
  - Subtask 1.3: Verify no output without DEBUG flag

- Task 2: Implement AppError class (AC: #4, #5)
  - Subtask 2.1: Create AppError class extending Error with exit code support
  - Subtask 2.2: Add serialization method for debug file output
  - Subtask 2.3: Ensure AppError instances follow clean code standards

- Task 3: Integration testing (AC: #1, #3, #4)
  - Subtask 3.1: Test logging output with different DEBUG patterns
  - Subtask 3.2: Verify AppError serialization works correctly
  - Subtask 3.3: Confirm zero console output in normal operation
    </tasks>
  </story>

  <acceptanceCriteria>
1. DEBUG environment variable support - System only produces output when `DEBUG=ollatool:*` is set
2. Namespaced logging - Separate loggers for git operations (`ollatool:git`), LLM interactions (`ollatool:llm`), and performance metrics (`ollatool:perf`)
3. Zero console output - No logs appear in normal operation without DEBUG flag
4. AppError class with serialization - Custom error class supporting debug file output with stack traces
5. Clean code standards - All logging code follows ≤15 lines per function requirement
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>dev/architecture.md</path>
        <title>Architecture Document</title>
        <section>Error Handling Strategy</section>
        <snippet>Defines typed error classes with exit codes: User=2, System=3, Validation=4, Unexpected=5. AppError base class with message, code, and remediation properties.</snippet>
      </doc>
      <doc>
        <path>dev/architecture.md</path>
        <title>Architecture Document</title>
        <section>Logging Strategy</section>
        <snippet>MVP uses minimal logging with DEBUG mode. No runtime console logs. Error logging to ~/.ollatool/debug.log for unexpected errors only.</snippet>
      </doc>
      <doc>
        <path>dev/sprint-artifacts/tech-spec-epic-0.md</path>
        <title>Epic 0 Technical Specification</title>
        <section>Debug Logging</section>
        <snippet>DEBUG environment variable with namespaces (git, llm, perf, validation). AppError class with serialization for debug output. No console output without DEBUG flag.</snippet>
      </doc>
      <doc>
        <path>dev/styleguides/clean-code.md</path>
        <title>Clean Code Standards</title>
        <section>Function Size &amp; Class Member Ordering</section>
        <snippet>Maximum 15 lines per function. Class ordering: Constructor → Private Properties → Public Properties → Public Methods → Private Methods.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>vitest.config.ts</path>
        <kind>config</kind>
        <symbol>defineConfig</symbol>
        <lines>1-34</lines>
        <reason>Shows test configuration with path aliases (@, @tests) and coverage settings. Tests will verify logging behavior.</reason>
      </artifact>
      <artifact>
        <path>tsconfig.json</path>
        <kind>config</kind>
        <symbol>compilerOptions</symbol>
        <lines>1-30</lines>
        <reason>TypeScript configuration with strict mode, ES2022 target, and path aliases. Error classes must follow strict type checking.</reason>
      </artifact>
      <artifact>
        <path>package.json</path>
        <kind>config</kind>
        <symbol>devDependencies</symbol>
        <lines>17-26</lines>
        <reason>Current dependencies include debug package already installed. AppError will be pure TypeScript with no new deps.</reason>
      </artifact>
    </code>
    <dependencies>
      <node>
        <package name="debug" version="^4.4.3">DEBUG environment variable logging library (already installed)</package>
        <package name="typescript" version="^5.9.3">Type safety for error classes</package>
        <package name="vitest" version="^4.0.14">Test framework for logging behavior validation</package>
      </node>
    </dependencies>
  </artifacts>

  <constraints>
- Follow hexagonal architecture: Error types in src/core/types/errors.types.ts (domain layer, no external deps)
- Logging adapters can be in infrastructure layer if needed, but debug package usage should be isolated
- Maximum 15 lines per function (clean code standard)
- Class member ordering: Constructor → Private Properties → Public Methods → Private Methods
- Zero console output in normal operation - only DEBUG mode produces logs
- AppError must support serialization for debug file output with stack traces
- All code must pass strict TypeScript checking
- Co-located tests: errors.types.test.ts adjacent to errors.types.ts
- Coverage target: ≥80% for error handling and logging logic
  </constraints>

  <interfaces>
    <interface>
      <name>AppError</name>
      <kind>class</kind>
      <signature>class AppError extends Error { constructor(message: string, code: number, remediation?: string); serialize(): object; }</signature>
      <path>src/core/types/errors.types.ts</path>
    </interface>
    <interface>
      <name>UserError</name>
      <kind>class</kind>
      <signature>class UserError extends AppError { constructor(message: string, remediation: string); }</signature>
      <path>src/core/types/errors.types.ts</path>
    </interface>
    <interface>
      <name>SystemError</name>
      <kind>class</kind>
      <signature>class SystemError extends AppError { constructor(message: string, remediation: string); }</signature>
      <path>src/core/types/errors.types.ts</path>
    </interface>
    <interface>
      <name>ValidationError</name>
      <kind>class</kind>
      <signature>class ValidationError extends AppError { constructor(message: string, remediation?: string); }</signature>
      <path>src/core/types/errors.types.ts</path>
    </interface>
    <interface>
      <name>Debug Logger</name>
      <kind>function</kind>
      <signature>debug(namespace: string): Debugger</signature>
      <path>Imported from debug package</path>
    </interface>
  </interfaces>

  <tests>
    <standards>
Co-located tests using Vitest with globals enabled. Test files adjacent to source (*.test.ts pattern). Coverage thresholds: 80% for lines, functions, branches, statements. Mock environment variables for testing different DEBUG configurations. Clean code standards apply to test code.
    </standards>
    <locations>
- src/core/types/errors.types.test.ts (co-located with implementation)
- Integration tests in tests/integration/ if needed for cross-cutting logging behavior
    </locations>
    <ideas>
      <idea ac="1,2">Test logger instantiation for each namespace (ollatool:git, ollatool:llm, ollatool:perf). Verify no output when DEBUG is not set. Verify output appears when DEBUG=ollatool:* is set.</idea>
      <idea ac="3">Mock process.env and console to verify zero output in normal operation. Test that setting DEBUG flag enables logging.</idea>
      <idea ac="4">Test AppError serialization produces object with message, code, stack, remediation. Test each error subclass (UserError, SystemError, ValidationError) with correct exit codes.</idea>
      <idea ac="5">Validate all logging functions are ≤15 lines. Test class member ordering follows standards.</idea>
    </ideas>
  </tests>
</story-context>
