<story-context id="dev/sprint-artifacts/1-5-setup-hexagonal-architecture-structure.context.xml" v="1.0">
  <metadata>
    <epicId>1</epicId>
    <storyId>5</storyId>
    <title>Setup Hexagonal Architecture Structure</title>
    <status>ready-for-dev</status>
    <generatedAt>2025-11-29</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>dev/sprint-artifacts/1-5-setup-hexagonal-architecture-structure.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>hexagonal architecture directory structure with example patterns</iWant>
    <soThat>I can follow consistent architectural patterns for future business logic implementation</soThat>
    <tasks>Create hexagonal directory structure with proper layer organization
- Create example port interface in src/core/ports/ following pattern from tech-spec
- Create example adapter in src/infrastructure/adapters/ implementing the port
- Create architecture README documenting layer responsibilities and dependency flow
- Validate structure passes build with no broken imports or TypeScript errors</tasks>
  </story>

  <acceptanceCriteria>1. Hexagonal directory structure created with proper layer organization
2. Example port interface created in src/core/ports/ following pattern from tech-spec
3. Example adapter created in src/infrastructure/adapters/ implementing the port
4. Architecture README created documenting layer responsibilities and dependency flow
5. Build passes with new structure (no broken imports or TypeScript errors)</acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>dev/sprint-artifacts/tech-spec-epic-1.md</path>
        <title>Epic 1 Technical Specification</title>
        <section>Hexagonal Layer Responsibilities</section>
        <snippet>Core layer has no external dependencies. Infrastructure adapters implement Core ports. Dependency flow: UI → Features → Core, Infrastructure implements Core ports</snippet>
      </doc>
      <doc>
        <path>dev/architecture.md</path>
        <title>Architecture Document</title>
        <section>Pragmatic Hexagonal Architecture</section>
        <snippet>Implement hexagonal architecture with manual dependency injection. No IoC containers. Core layer contains domain types and port interfaces with zero external dependencies</snippet>
      </doc>
      <doc>
        <path>dev/styleguides/clean-code.md</path>
        <title>Clean Code Standards</title>
        <section>Class Design Principles</section>
        <snippet>Functions ≤15 lines, 0-2 arguments maximum. Constructor injection only. Class member ordering: Constructor → Private Properties → Public Properties → Public Methods → Private Methods</snippet>
      </doc>
      <doc>
        <path>dev/styleguides/unit-test-patterns.md</path>
        <title>Unit Test Patterns</title>
        <section>Test Real Logic Only</section>
        <snippet>Directory creation and documentation don't need tests. Only test actual logic with real working behavior, not placeholder functionality</snippet>
      </doc>
      <doc>
        <path>dev/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Epic 1: Foundation & Project Setup</section>
        <snippet>Epic 1 establishes foundational modules and project structure. Story 1.5 creates directory structure with example port/adapter demonstrating the pattern</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/index.ts</path>
        <kind>barrel-file</kind>
        <symbol>index</symbol>
        <lines>1-5</lines>
        <reason>Establishes barrel file pattern with shebang and import-only structure - use same pattern for new index.ts files</reason>
      </artifact>
      <artifact>
        <path>src/main.ts</path>
        <kind>cli-bootstrap</kind>
        <symbol>createProgram</symbol>
        <lines>1-50</lines>
        <reason>Demonstrates composition root pattern for dependency injection - follow this pattern for future adapter composition</reason>
      </artifact>
      <artifact>
        <path>src/core/types/errors.types.ts</path>
        <kind>domain-types</kind>
        <symbol>AppError, UserError, SystemError</symbol>
        <lines>1-80</lines>
        <reason>Reusable error classes that should be used across all layers - import for adapter error handling</reason>
      </artifact>
      <artifact>
        <path>src/infrastructure/logging/debug-loggers.ts</path>
        <kind>infrastructure</kind>
        <symbol>createLogger</symbol>
        <lines>1-40</lines>
        <reason>Demonstrates infrastructure layer pattern - adapters can use this logging approach</reason>
      </artifact>
    </code>
    <dependencies>
      <ecosystem name="node">
        <package name="commander" version="14.0.2" purpose="CLI framework for command parsing" />
        <package name="ollama" version="0.6.3" purpose="Will be used in future OllamaAdapter" />
        <package name="debug" version="4.4.3" purpose="DEBUG logging system - already used in error types" />
        <package name="execa" version="9.6.0" purpose="Will be used in future GitAdapter" />
      </ecosystem>
      <ecosystem name="development">
        <package name="typescript" version="5.9.3" purpose="Strict mode enabled for new code" />
        <package name="vitest" version="4.0.14" purpose="Testing framework with co-located pattern" />
        <package name="tsup" version="latest" purpose="Build system - new structure must work with existing config" />
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="architecture-pattern" severity="high">Must implement pragmatic hexagonal architecture with manual dependency injection. No IoC containers</constraint>
    <constraint id="layer-separation" severity="high">Core layer must have ZERO external dependencies. Infrastructure adapters implement core interfaces</constraint>
    <constraint id="dependency-flow" severity="high">UI → Features → Core, Infrastructure implements Core ports. Inward dependency flow only</constraint>
    <constraint id="clean-code" severity="medium">Functions ≤15 lines, 0-2 arguments maximum. Constructor injection only</constraint>
    <constraint id="file-naming" severity="medium">Kebab-case for all files (e.g., example-adapter.ts). PascalCase for classes</constraint>
    <constraint id="barrel-files" severity="medium">All index.ts files contain ONLY re-exports, no logic, no tests needed</constraint>
    <constraint id="typescript-strict" severity="high">All new code must pass strict type checking and ESM imports</constraint>
    <constraint id="build-compatibility" severity="high">New structure must work with existing tsup configuration and build output</constraint>
    <constraint id="test-scope" severity="high">NO tests for directory structure or documentation. Only test real working logic in adapter</constraint>
  </constraints>
  <interfaces>
    <interface name="ExamplePort" kind="port-interface">
      <signature>export interface ExamplePort {
  process(input: string): Promise&lt;string&gt;;
}</signature>
      <path>src/core/ports/example-port.ts</path>
    </interface>
    <interface name="ExampleAdapter" kind="adapter-implementation">
      <signature>export class ExampleAdapter implements ExamplePort {
  async process(input: string): Promise&lt;string&gt; {
    // Working logic, not placeholder
    return input.toUpperCase();
  }
}</signature>
      <path>src/infrastructure/adapters/example-adapter.ts</path>
    </interface>
    <interface name="Error Types" kind="domain-types">
      <signature>AppError, UserError, SystemError, ValidationError, UnexpectedError</signature>
      <path>src/core/types/errors.types.ts</path>
    </interface>
  </interfaces>
  <tests>
    <standards>Use Vitest with co-located test pattern (.test.ts files next to source). Test only real logic with working behavior, not directory creation or documentation. Follow user-visible outcomes testing - test public API inputs and outputs only. Use getData() pattern for test data organization.</standards>
    <locations>Tests co-located with implementation files (e.g., example-adapter.test.ts next to example-adapter.ts). Test discovery pattern: **/*.test.ts excludes node_modules, dist, and config files.</locations>
    <ideas>
      <test idea="adapter-functionality" ac="3">Test ExampleAdapter.process() method with real input/output behavior if implementing working logic beyond placeholder</test>
      <test idea="interface-compliance" ac="2-3">Verify adapter correctly implements port interface contract through actual usage</test>
      <test idea="build-validation" ac="5">Run npm run build to ensure no TypeScript errors with new structure</test>
    </ideas>
  </tests>
</story-context>