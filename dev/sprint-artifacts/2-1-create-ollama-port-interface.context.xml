<story-context id="{bmad_folder}/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>1</storyId>
    <title>create-ollama-port-interface</title>
    <status>drafted</status>
    <generatedAt>2025-11-30</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>dev/sprint-artifacts/2-1-create-ollama-port-interface.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a developer</asA>
    <iWant>a port interface defining Ollama operations</iWant>
    <soThat>the core domain doesn't depend on the Ollama SDK implementation</soThat>
    <tasks>- Create LlmPort interface file (AC: 1)
  - Create `src/core/ports/llm-port.ts` with interface definition
  - Ensure core/ports directory exists per hexagonal architecture
- Define interface methods (AC: 2)
  - Add `checkConnection(): Promise<boolean>` for daemon availability
  - Add `checkModel(modelName: string): Promise<boolean>` for model existence
  - Add `createModel(modelName: string, modelfileContent: string): Promise<void>` for custom model creation
  - Add `generate(prompt: string, options: GenerationOptions): Promise<string>` for future Epic 4 use
- Create supporting type definitions (AC: 3)
  - Define `GenerationOptions` interface with model, temperature, num_ctx, keep_alive fields
  - Export both interface and types from the file
- Add comprehensive JSDoc documentation (AC: 4)
  - Document each method with @param, @returns, @throws
  - Explain the purpose and usage patterns
  - Include examples for complex methods like generate()
- Validate core layer isolation (AC: 5)
  - Verify no external imports (no 'ollama', 'execa', 'fs' in core/)
  - Ensure file contains only TypeScript interfaces and types
  - Run import analysis to confirm zero external dependencies
- Apply clean code standards (AC: 6)
  - Review interface for clear, self-documenting method names
  - Ensure JSDoc follows established patterns
  - Run linting to verify all standards are met</tasks>
  </story>

  <acceptanceCriteria>1. [ ] Interface created in `src/core/ports/llm-port.ts`
2. [ ] Methods defined: `checkConnection()`, `checkModel()`, `createModel()`, `generate()`
3. [ ] Type definitions for `GenerationOptions` interface with model, temperature, num_ctx, keep_alive
4. [ ] Interface documented with JSDoc explaining parameters and return types
5. [ ] Zero external dependencies in core/ layer (verified via import analysis)
6. [ ] Code adheres to clean-code.md: functions ≤15 lines, self-documenting names</acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>dev/sprint-artifacts/tech-spec-epic-2.md</path>
        <title>Epic Technical Specification: Ollama Integration & Model Management</title>
        <section>Data Models and Contracts (lines 85-128)</section>
        <snippet>Complete LlmPort interface definition with methods: checkConnection(), checkModel(), createModel(), generate() and GenerationOptions interface with model, temperature, num_ctx, keep_alive fields.</snippet>
      </doc>
      <doc>
        <path>dev/architecture.md</path>
        <title>System Architecture Document</title>
        <section>Project Structure (Pragmatic Hexagonal / Ports & Adapters)</section>
        <snippet>Core layer defines ports (interfaces) with zero external dependencies. Hexagonal architecture pattern with clear dependency flow inward: Core → Ports (interfaces) → Adapters (implementations).</snippet>
      </doc>
      <doc>
        <path>dev/sprint-artifacts/tech-spec-epic-2.md</path>
        <title>Epic 2 Technical Specification</title>
        <section>System Architecture Alignment (lines 48-55)</section>
        <snippet>Implementation follows hexagonal architecture: Core Layer (Ports) with zero external dependencies, Infrastructure Layer (Adapters) using ollama SDK, Features Layer (Use Cases) for setup orchestration.</snippet>
      </doc>
      <doc>
        <path>/goldbergyoni/nodebestpractices</path>
        <title>Node.js Best Practices (Context7 MCP)</title>
        <section>Interface Design & TypeScript Patterns</section>
        <snippet>Use explicit type definitions, prefer const for immutable values, follow naming conventions (UpperCamelCase for interfaces, lowerCamelCase for methods), and avoid deep imports - use index files as public entry points.</snippet>
      </doc>
    </docs>
    <code>
      <code>
        <path>src/core/ports/example-port.ts</path>
        <kind>interface</kind>
        <symbol>ExamplePort</symbol>
        <lines>1-26</lines>
        <reason>Demonstrates port interface pattern with zero external dependencies and JSDoc documentation patterns to follow for LlmPort interface.</reason>
      </code>
      <code>
        <path>src/core/types/errors.types.ts</path>
        <kind>error-classes</kind>
        <symbol>SystemError, ValidationError</symbol>
        <lines>92-106</lines>
        <reason>Provides typed error classes with exit codes that LlmPort methods should throw when appropriate - SystemError (code 3) for system failures, ValidationError (code 4) for validation issues.</reason>
      </code>
      <code>
        <path>src/core/ports/index.ts</path>
        <kind>barrel-export</kind>
        <symbol>index barrel file</symbol>
        <lines>1-9</lines>
        <reason>Pattern to follow - must add export for new LlmPort interface in this barrel file for clean import structure and avoid deep imports.</reason>
      </code>
    </code>
    <dependencies>
      <ecosystem name="Node.js">
        <package name="typescript" version="^5.9.3" />
        <package name="@types/node" version="^24.10.1" />
      </ecosystem>
      <ecosystem name="Ollama">
        <package name="ollama" version="^0.6.3" />
      </ecosystem>
      <ecosystem name="Development">
        <package name="vitest" version="^4.0.14" />
        <package name="eslint" version="^9.39.1" />
        <package name="prettier" version="^3.0.0" />
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
  <constraint>
    <name>Core Layer Isolation</name>
    <type>architectural</type>
    <rule>Core layer must have ZERO external dependencies - no imports from 'ollama', 'execa', 'fs', 'path', or any external libraries. Only TypeScript type imports allowed.</rule>
    <source>dev/architecture.md#Project-Structure-(Pragmatic-Hexagonal/-Ports-&-Adapters)</source>
    <enforcement>Import analysis verification, TypeScript compilation with strict mode</enforcement>
  </constraint>
  <constraint>
    <name>Interface Naming Conventions</name>
    <type>coding-standard</type>
    <rule>Interfaces use UpperCamelCase (LlmPort), methods use lowerCamelCase (checkConnection), parameters use lowerCamelCase with descriptive names.</rule>
    <source>/goldbergyoni/nodebestpractices (Context7 MCP)</source>
    <enforcement>ESLint rules, TypeScript compilation</enforcement>
  </constraint>
  <constraint>
    <name>Function Size Limit</name>
    <type>quality</type>
    <rule>All functions must be ≤15 lines per clean-code.md standards. Interface definitions typically exempt, but JSDoc comments should be concise.</rule>
    <source>dev/styleguides/clean-code.md</source>
    <enforcement>ESLint max-lines-per-function rule</enforcement>
  </constraint>
  <constraint>
    <name>Self-Documenting Code</name>
    <type>documentation</type>
    <rule>Interface and method names must be self-documenting. JSDoc comments explain "why" not "what". Include @param, @returns, @throws with clear descriptions.</rule>
    <source>dev/styleguides/clean-code.md</source>
    <enforcement>Code review, ESLint jsdoc/require-jsdoc rule</enforcement>
  </constraint>
  <constraint>
    <name>TypeScript Strict Mode</name>
    <type>type-safety</type>
    <rule>All interfaces must compile with TypeScript strict mode enabled. No implicit any types, all parameters must have explicit types.</rule>
    <source>dev/sprint-artifacts/1-1-initialize-typescript-project-with-esm.md</source>
    <enforcement>npm run typecheck, TypeScript compiler</enforcement>
  </constraint>
  <constraint>
    <name>No External SDK References</name>
    <type>boundary</type>
    <rule>Core layer ports cannot reference external SDK types (like Ollama types). Define all required types locally within the interface file.</rule>
    <source>dev/sprint-artifacts/tech-spec-epic-2.md#System-Architecture-Alignment</source>
    <enforcement>Import analysis, TypeScript compilation</enforcement>
  </constraint>
</constraints>
  <interfaces>
  <interface>
    <name>LlmPort</name>
    <kind>Port Interface</kind>
    <signature>
export interface LlmPort {
  checkConnection(): Promise&lt;boolean&gt;;
  checkModel(modelName: string): Promise&lt;boolean&gt;;
  createModel(modelName: string, modelfileContent: string): Promise&lt;void&gt;;
  generate(prompt: string, options: GenerationOptions): Promise&lt;string&gt;;
}</signature>
    <purpose>Defines contract for LLM provider operations while keeping core business logic isolated from external dependencies</purpose>
    <methods>
      <method>
        <name>checkConnection</name>
        <signature>(): Promise&lt;boolean&gt;</signature>
        <purpose>Check if Ollama daemon is running and accessible via health check</purpose>
        <returns>true if daemon responds to health check, false on connection failure</returns>
      </method>
      <method>
        <name>checkModel</name>
        <signature>(modelName: string): Promise&lt;boolean&gt;</signature>
        <purpose>Verify if a specific model exists in local Ollama registry</purpose>
        <param>modelName - Full model identifier (e.g., 'qwen2.5-coder:1.5b')</param>
        <returns>true if model is available locally</returns>
      </method>
      <method>
        <name>createModel</name>
        <signature>(modelName: string, modelfileContent: string): Promise&lt;void&gt;</signature>
        <purpose>Create custom model instance from Modelfile</purpose>
        <param>modelName - Name for custom model (e.g., 'ollatool-commit:latest')</param>
        <param>modelfileContent - Complete Modelfile definition</param>
        <throws>ValidationError if creation fails</throws>
      </method>
      <method>
        <name>generate</name>
        <signature>(prompt: string, options: GenerationOptions): Promise&lt;string&gt;</signature>
        <purpose>Generate text from prompt (used in Epic 4)</purpose>
        <param>prompt - User prompt with diff context</param>
        <param>options - Generation parameters (temperature, etc.)</param>
        <returns>Generated commit message</returns>
      </method>
    </methods>
  </interface>
  <interface>
    <name>GenerationOptions</name>
    <kind>Type Interface</kind>
    <signature>
export interface GenerationOptions {
  model: string;
  temperature?: number;
  num_ctx?: number;
  keep_alive?: number;
}</signature>
    <purpose>Configuration options for LLM generation parameters</purpose>
    <fields>
      <field>
        <name>model</name>
        <type>string</type>
        <purpose>Model identifier to use for generation</purpose>
      </field>
      <field>
        <name>temperature</name>
        <type>number?</type>
        <purpose>Randomness control (0.0-1.0), lower values more deterministic</purpose>
      </field>
      <field>
        <name>num_ctx</name>
        <type>number?</type>
        <purpose>Context window size for generation</purpose>
      </field>
      <field>
        <name>keep_alive</name>
        <type>number?</type>
        <purpose>Model keep-alive duration in minutes</purpose>
      </field>
    </fields>
  </interface>
</interfaces>
  <tests>
    <standards>
Interface definitions don't require runtime tests as TypeScript provides compile-time safety. Focus testing on adapter implementations that consume this interface. Use co-located test files with Vitest framework following the project pattern (src/core/ports/example-port.ts → src/core/ports/example-port.test.ts). Mock external dependencies at test boundaries, not interface definitions themselves.
    </standards>
    <locations>
      - src/core/ports/*.test.ts (co-located with interface files)
      - src/infrastructure/adapters/*.test.ts (adapter implementations)
      - tests/integration/ (end-to-end integration tests)
    </locations>
    <ideas>
      <testIdea acId="AC-2.1.5">
        <description>Import analysis test - verify src/core/ports/llm-port.ts has zero external dependencies</description>
        <testType>static-analysis</testType>
      </testIdea>
      <testIdea acId="AC-2.1.2">
        <description>Interface completeness test - verify all required methods are present in LlmPort interface</description>
        <testType>compilation</testType>
      </testIdea>
      <testIdea acId="AC-2.1.3">
        <description>Type completeness test - verify GenerationOptions interface has all required fields</description>
        <testType>compilation</testType>
      </testIdea>
      <testIdea acId="AC-2.1.4">
        <description>JSDoc coverage test - verify all interface methods have comprehensive JSDoc documentation</description>
        <testType>documentation</testType>
      </testIdea>
      <testIdea acId="AC-2.1.6">
        <description>Code quality test - verify interface follows clean code naming conventions and size limits</description>
        <testType>linting</testType>
      </testIdea>
    </ideas>
  </tests>
</story-context>