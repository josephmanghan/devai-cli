<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>5</storyId>
    <title>Implement Setup Command</title>
    <status>drafted</status>
    <generatedAt>2025-11-30</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>dev/sprint-artifacts/2-5-implement-setup-command.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a developer</asA>
    <iWant>an `ollatool setup` command</iWant>
    <soThat>users can initialize Ollama integration before first commit with validation and model provisioning</soThat>
    <tasks>Create setup command structure and registration (AC: 1)
- Add setup command to Commander.js configuration in main.ts
- Create SetupCommand class in src/features/setup/setup-command.ts
- Implement proper dependency injection pattern following hexagonal architecture
- Implement command handler orchestration logic (AC: 2, 3)
- Create setup workflow that validates Ollama daemon connectivity
- Add base model existence check (`qwen2.5-coder:1.5b`)
- Add custom model existence check (`ollatool-commit:latest`)
- Orchestrate model creation if missing using OllamaAdapter
- Add comprehensive validation and feedback (AC: 4, 5, 7)
- Implement daemon connectivity check with actionable error messages
- Add base model validation with pull instructions if missing
- Integrate custom model creation using existing OllamaAdapter.createModel()
- Display clear progress feedback during model creation
- Show success confirmation when setup completes
- Implement idempotency and error handling (AC: 6, 7)
- Skip operations that are already complete with informational messages
- Handle different error types with appropriate exit codes
- Provide remediation guidance for each error scenario
- Create comprehensive unit tests
- Test command registration and entry point
- Test daemon validation success and failure scenarios
- Test base model validation with missing model handling
- Test custom model creation orchestration
- Test idempotency when all components already exist
- Test error handling and exit code mapping
- Add integration testing for end-to-end validation
- Create integration test for real Ollama environment
- Validate setup command works with running Ollama daemon
- Test error scenarios when Ollama not installed/running
- Run `npm run pr` to validate implementation is ready for PR</tasks>
  </story>

  <acceptanceCriteria>1. [ ] Setup command registered in Commander.js with proper `ollatool setup` entry point
2. [ ] Command handler created in `src/features/setup/setup-command.ts` following hexagonal architecture
3. [ ] Performs 3-tier validation: daemon → base model → custom model existence checks
4. [ ] Creates custom `ollatool-commit:latest` model if missing using configured adapter
5. [ ] Shows clear success/failure messages with remediation guidance for each failure type
6. [ ] Command is idempotent (safe to re-run multiple times without side effects)
7. [ ] Error handling with proper exit codes: daemon=3, validation=4, system=3</acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="dev/prd.md" title="Product Requirements Document" section="First-Run Model Provisioning Flow" snippet="The tool requires both base model download AND custom model creation (with system prompt baked in via Modelfile). This only works if Ollama is running." />
      <doc path="dev/prd.md" title="Product Requirements Document" section="CLI Tool Specific Requirements" snippet="Exit codes: 0 (success), 1 (user cancel), 2 (error - no staged changes), 3 (error - Ollama unavailable)" />
      <doc path="dev/architecture.md" title="Architecture Document" section="Setup Command Implementation" snippet="Command: `ollatool setup` - Purpose: One-time configuration of Ollama integration and model provisioning (idempotent - safe to run multiple times)" />
      <doc path="dev/architecture.md" title="Architecture Document" section="3-Tier Validation Pattern" snippet="Daemon connectivity (HTTP GET to localhost:11434), Base model existence (qwen2.5-coder:1.5b), Custom model existence (ollatool-commit:latest)" />
      <doc path="dev/architecture.md" title="Architecture Document" section="Ollama Model Architecture" snippet="Configuration-Based System Prompt: Role definition and behavioral constraints stored in configuration files, Applied at model creation time via SDK parameters" />
      <doc path="dev/epics.md" title="Epics Document" section="Epic 2: Ollama Integration & Model Management" snippet="Goal: Enable reliable connection to Ollama and model lifecycle management. User Value: Users can successfully setup the tool and verify Ollama connectivity before attempting commits" />
    </docs>
    <code>
      <code path="src/infrastructure/llm/ollama-adapter.ts" kind="adapter" symbol="OllamaAdapter" lines="24-29" reason="Generic Ollama adapter with constructor injection for base model, system prompt, and parameters - can be reused for setup command" />
      <code path="src/infrastructure/llm/ollama-adapter.ts" kind="method" symbol="checkConnection" lines="35-42" reason="Existing method for daemon connectivity validation via HTTP check" />
      <code path="src/infrastructure/llm/ollama-adapter.ts" kind="method" symbol="checkModel" lines="50-57" reason="Existing method for model existence validation using ollama.list()" />
      <code path="src/infrastructure/llm/ollama-adapter.ts" kind="method" symbol="createModel" lines="64-74" reason="Existing method for custom model creation with progress feedback and error handling" />
      <code path="src/infrastructure/config/conventional-commit-model.config.ts" kind="config" symbol="CONVENTIONAL_COMMIT_MODEL_CONFIG" lines="7-40" reason="Complete configuration for custom model creation including system prompt, base model, and parameters" />
      <code path="src/main.ts" kind="entry" symbol="createProgram" lines="19-31" reason="Commander.js program structure where setup command should be registered" />
      <code path="src/core/types/errors.types.ts" kind="types" symbol="SystemError, ValidationError" reason="Typed error classes with exit codes and remediation guidance for error handling" />
    </code>
    <dependencies>
      <runtime>
        <package name="commander" version="14.0.2" purpose="CLI argument parsing and command structure" />
        <package name="ora" version="9.0.0" purpose="Terminal spinner for loading states during model creation" />
        <package name="ollama" version="0.6.3" purpose="Official Ollama SDK for model operations and daemon communication" />
      </runtime>
      <dev>
        <package name="vitest" version="4.0.14" purpose="Modern test runner with native ESM support and mocking capabilities" />
        <package name="tsx" version="latest" purpose="TypeScript execution for development and testing" />
        <package name="tsup" version="latest" purpose="Fast ESM bundling for CLI distribution" />
      </dev>
    </dependencies>
  </artifacts>

  <constraints>
  <constraint id="architecture">Follow hexagonal architecture with manual dependency injection - setup command must be placed in src/features/setup/ and orchestrate use cases through clean interfaces</constraint>
  <constraint id="cli-integration">Register setup command in main.ts following same pattern as future commands - use Commander.js with proper help text and error handling</constraint>
  <constraint id="3-tier-validation">Sequential validation: daemon connectivity → base model (qwen2.5-coder:1.5b) → custom model (ollatool-commit:latest) with clear error messages at each stage</constraint>
  <constraint id="idempotency">Setup command must be safe to re-run multiple times - check model existence before creation and provide informational messages for already-complete operations</constraint>
  <constraint id="error-codes">Use specific exit codes: SystemError (exit 3) for daemon issues, ValidationError (exit 4) for model validation failures, with actionable remediation guidance</constraint>
  <constraint id="progress-feedback">Use ora spinner for long-running operations (model creation) with clear status messages and professional Unicode dots animation</constraint>
  <constraint id="configuration-based">Use existing CONVENTIONAL_COMMIT_MODEL_CONFIG for custom model creation - do not hardcode model parameters in the setup command</constraint>
  <constraint id="file-placement">CRITICAL: New files MUST go in correct architectural layers. CREATE: src/features/setup/setup-command.ts (command handler), src/features/setup/setup-command.test.ts (unit tests). MODIFY: src/main.ts (command registration only). DO NOT CREATE files in: ui/ (no UI components - only console output), core/ports/ (reuse existing LlmPort), core/types/ (reuse existing error types), infrastructure/adapters/ (reuse existing OllamaAdapter), infrastructure/config/ (reuse existing CONVENTIONAL_COMMIT_MODEL_CONFIG). Violating this creates architectural drift and defeats hexagonal pattern.</constraint>
</constraints>
  <interfaces>
  <interface name="LlmPort" kind="port" signature="checkConnection(): Promise<boolean>, checkModel(modelName: string): Promise<boolean>, createModel(modelName: string): Promise<void>" path="src/core/ports/llm-port.ts" />
  <interface name="SystemError" kind="error-class" signature="constructor(message: string, remediation: string): SystemError" path="src/core/types/errors.types.ts" exit-code="3" />
  <interface name="ValidationError" kind="error-class" signature="constructor(message: string, remediation?: string): ValidationError" path="src/core/types/errors.types.ts" exit-code="4" />
  <interface name="OllamaModelConfig" kind="config" signature="model: string, baseModel: string, systemPrompt: string, parameters: Record<string, unknown>" path="src/core/types/llm-types.ts" />
  <interface name="Commander.js Command" kind="cli" signature="program.command(name): Command, .description(text): Command, .action(callback): Command" path="https://commander.js.org/" />
</interfaces>
  <implementationPatterns>
    <pattern id="dependency-injection" critical="true">
      <description>How to instantiate OllamaAdapter with CONVENTIONAL_COMMIT_MODEL_CONFIG for setup command</description>
      <code><![CDATA[import { Ollama } from 'ollama';
import { OllamaAdapter } from '../../infrastructure/llm/ollama-adapter.js';
import { CONVENTIONAL_COMMIT_MODEL_CONFIG } from '../../infrastructure/config/conventional-commit-model.config.js';

// Create Ollama client instance
const ollamaClient = new Ollama();

// Wire config into adapter - NOTE: field mapping
const adapter = new OllamaAdapter(
  ollamaClient,
  CONVENTIONAL_COMMIT_MODEL_CONFIG.baseModel,    // 'qwen2.5-coder:1.5b'
  CONVENTIONAL_COMMIT_MODEL_CONFIG.systemPrompt, // Full conventional commits prompt
  CONVENTIONAL_COMMIT_MODEL_CONFIG.parameters    // { temperature: 0.2, num_ctx: 131072, keep_alive: 0 }
);]]></code>
      <rationale>Config structure has 'model' and 'baseModel' fields - constructor needs 'baseModel' for creation. The 'model' field (ollatool-commit:latest) is the OUTPUT name, not a constructor param.</rationale>
    </pattern>
    <pattern id="model-name-usage" critical="true">
      <description>Which model name to pass to createModel() method</description>
      <code><![CDATA[// Use the 'model' field from config as the custom model name
await adapter.createModel(CONVENTIONAL_COMMIT_MODEL_CONFIG.model); // 'ollatool-commit:latest'

// For model existence checks:
const baseExists = await adapter.checkModel(CONVENTIONAL_COMMIT_MODEL_CONFIG.baseModel);    // 'qwen2.5-coder:1.5b'
const customExists = await adapter.checkModel(CONVENTIONAL_COMMIT_MODEL_CONFIG.model);      // 'ollatool-commit:latest']]></code>
      <rationale>Config has TWO model names: 'baseModel' (source) and 'model' (target). Use 'model' for createModel(), both for checkModel().</rationale>
    </pattern>
    <pattern id="command-registration" critical="true">
      <description>First command - establishes pattern for main.ts integration</description>
      <code><![CDATA[// In main.ts createProgram() function
export function createProgram(): Command {
  const program = new Command();

  program
    .name('ollatool')
    .description('Local-first CLI tool for AI-powered git commit message generation using Ollama')
    .version(pkg.version, '--version', 'Show version number');

  // Setup command registration
  program
    .command('setup')
    .description('Configure Ollama integration and provision custom model')
    .action(async () => {
      try {
        const ollamaClient = new Ollama();
        const adapter = new OllamaAdapter(/* ... config wiring ... */);

        // 3-tier validation
        if (!await adapter.checkConnection()) {
          throw new SystemError('Ollama daemon not running', 'Start Ollama: ollama serve');
        }

        // Base model check
        // Custom model check and creation
        // Success message

      } catch (error) {
        if (error instanceof AppError) {
          console.error(`[ERROR] ✗ ${error.message}\n`);
          if (error.remediation) console.error(error.remediation);
          console.error(`\nExit code: ${error.code}`);
          process.exit(error.code);
        }
        throw error;
      }
    });

  return program;
}]]></code>
      <rationale>This is the FIRST command - sets the pattern for future commands. Use .command().action() pattern with error handling in action callback.</rationale>
    </pattern>
    <pattern id="error-handling-display" critical="true">
      <description>How to catch and display SystemError/ValidationError from OllamaAdapter</description>
      <code><![CDATA[import { AppError, SystemError, ValidationError } from '../../core/types/errors.types.js';

try {
  // Setup operations that may throw
  await adapter.checkConnection();
  await adapter.createModel(modelName);
} catch (error) {
  // OllamaAdapter throws AppError subclasses (SystemError, ValidationError)
  if (error instanceof AppError) {
    console.error(`[ERROR] ✗ ${error.message}\n`);
    if (error.remediation) {
      console.error(error.remediation);
    }
    console.error(`\nExit code: ${error.code}`);
    process.exit(error.code); // Exit with specific code (3 or 4)
  }
  // Unexpected errors re-throw
  throw error;
}]]></code>
      <rationale>OllamaAdapter already wraps errors as SystemError/ValidationError with remediation. Just display and exit with proper codes.</rationale>
    </pattern>
  </implementationPatterns>
  <tests>
    <standards>Vitest with co-located tests (.test.ts files). Mock-first approach for unit tests using Vitest utilities. Integration tests with mocked dependencies. Real Ollama E2E tests for validation. 80%+ branch coverage on core and features. Clean Code compliance with function size ≤15 lines and proper class member ordering.</standards>
    <locations>Unit tests: src/**/*.test.ts (co-located with source files). Integration tests: tests/integration/. E2E tests: tests/e2e/ with real Ollama daemon. Mock factories: tests/helpers/mock-factories.ts. Test fixtures: tests/helpers/test-fixtures.ts.</locations>
    <ideas>
      <test for="AC1" description="Test setup command registration in Commander.js program - verify command exists, has correct help text, and calls expected handler">
        Mock Commander.js program and verify .command('setup').description().action() are called
      </test>
      <test for="AC2" description="Test SetupCommand class follows hexagonal architecture with proper dependency injection">
        Mock OllamaAdapter in constructor, verify orchestrates use cases without direct SDK calls
      </test>
      <test for="AC3" description="Test 3-tier validation sequence: daemon → base model → custom model">
        Mock OllamaAdapter.checkConnection() to return true/false, test proper error handling and exit codes
      </test>
      <test for="AC4" description="Test custom model creation using CONVENTIONAL_COMMIT_MODEL_CONFIG">
        Verify OllamaAdapter.createModel() called with correct config parameters and progress feedback
      </test>
      <test for="AC5" description="Test success/failure messages with remediation guidance">
        Mock different error scenarios and verify appropriate SystemError/ValidationError with exit codes 3/4
      </test>
      <test for="AC6" description="Test idempotency - safe to re-run multiple times">
        Mock models already exist, verify setup skips operations and shows informational messages
      </test>
      <test for="AC7" description="Test error handling with proper exit codes mapping">
        Mock daemon failures (exit 3), validation failures (exit 4), verify remediation messages
      </test>
      <integration-test for="end-to-end" description="Integration test with real Ollama environment">
        Create temporary git repo, run setup command with real Ollama, validate model creation and success messages
      </integration-test>
      <integration-test for="error-scenarios" description="Test error scenarios when Ollama not installed/running">
        Mock Ollama daemon not running, verify clear error messages and exit code 3 with installation guidance
      </integration-test>
      <integration-test for="cleanup" description="CRITICAL: Integration tests MUST use test-specific model name and cleanup" critical="true">
        Use TEST-SPECIFIC model name like 'ollatool-commit-test:latest' (NOT 'ollatool-commit:latest') to avoid trampling real user models. Create test config similar to CONVENTIONAL_COMMIT_MODEL_CONFIG but with different model name. MUST cleanup in afterEach/afterAll using try-finally: await ollamaClient.delete({ model: 'ollatool-commit-test:latest' }). Only delete test model, never delete base model (qwen2.5-coder:1.5b) or production model (ollatool-commit:latest).
      </integration-test>
    </ideas>
  </tests>
</story-context>